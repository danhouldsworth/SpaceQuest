<html><head><canvas id="myCanvas" width=500 height=200 style="border:1px dotted"></canvas></br>
<script >

	var canvas = document.getElementById('myCanvas'); var context = canvas.getContext('2d'),

		particle	= [],
		magnet		= [],
		attachment	= [],
		wall		= new particle_type(),			// simulate wall as a infinitely large particle

		interaction	= new interaction_type(),		// interaction object is useful to have seperation x,y,vx,vy,mass etc

		gravity			= -0.001,
		friction_p		= 1,
		friction_b		= 10,
		restitution_p	= 1,
		restitution_b	= 1,
		boundary_flag_x	= -1,
		boundary_flag_y	= -1,
		distance_force	= 0,
		speedCap		= 50;

	var timerAnimate = setInterval(animate, 30),
		timerIterate = setInterval(iterate, 1);

	function iterate(){

		// -- 1. Iterate through the Particles. Resolving the Particle-to-Particle interactions
		for (var i = 0; i < particle.length; i++){

			interaction.clear();

			for (var j = i + 1; j < particle.length; j++){
				interaction.resolve(particle[i], particle[j]);
				particle[i].collide(particle[j], restitution_p, friction_p);
				particle[i].attract(particle[j]);
			}

			particle[i].boundary_test();
			particle[i].stabilise();
			particle[i].update();
		}
		// --

		// -- 2. Iterate throught the Magnets.
		// -- Resolving the Magnet-to-Particle, Magnet-to-Magnet & Magnet-to-Attachement interactions
		for (var i = 0; i < magnet.length; i++){

			interaction.clear();

			// -- Magnets Phyiscal collision barrier to particles
			for (var j = 0; j < particle.length; j++){
				interaction.resolve(magnet[i], particle[j]);
				magnet[i].collide(particle[j], restitution_p, friction_p);
			}
			// --

			// -- Magnets attracted in order
			if (i != magnet.length - 1){
				interaction.resolve(magnet[i], magnet[i + 1]);
				magnet[i].stick(magnet[i + 1]);
			}
			// --

			// -- If this magnet is named by an attachment then stick
			for (var j = 0; j < attachment.length; j++){
				if (i == attachment[j].magnet_number){
					interaction.resolve(magnet[i], attachment[j]);
					magnet[i].stick(attachment[j]);
				}
			}
			// --

			magnet[i].boundary_test();
			magnet[i].stabilise();
			magnet[i].update( -0.01 * magnet[i].mass() ); // Dampen the magnets with drag
		}
	}

	function animate(){
		function draw_all_of(type, shade){
			for (var i = 0; i < type.length; i++){
				type[i].draw(shade);
			}
		}

		canvas.width = canvas.width;
		draw_all_of(particle, 0);
		draw_all_of(magnet, 100);
		draw_all_of(attachment, 200);
	}

	function modulus(x, y) {
		return Math.sqrt(x * x + y * y);
	}

	function particle_type(x, y, vx, vy, size){
		this.x		= x;
		this.y		= y;
		this.vx		= vx;
		this.vy		= vy;
		this.size	= size;
		this.angle	= 0;
		this.spin	= 0;

		this.speed = function (){
			return modulus(this.vx, this.vy);
		}
		this.mass = function (){
			return (4/3) * Math.PI * this.size * this.size * this.size;
		}
	}

	particle_type.prototype.update = function(drag){

		// -- Modify speed due to gravity (& other field forces)
		this.vy 	+= gravity;
		// --

		// -- Modify speed due to drag
		if (drag){
			if (this.vx > 0){
				this.vx += Math.max(drag*this.vx*this.speed() / this.mass(), -this.vx);
			}
			else {
				this.vx += Math.min(drag*this.vx*this.speed() / this.mass(), -this.vx);
			}
			if (this.vy > 0){
				this.vy += Math.max(drag*this.vy*this.speed() / this.mass(), -this.vy);
			}
			else {
				this.vy += Math.min(drag*this.vy*this.speed() / this.mass(), -this.vy);
			}
		}
		// --

		// -- Update position based on speed
		this.x 		+= this.vx;
		this.y 		+= this.vy;
		this.angle 	+= this.spin;
		// --

		// -- Normalise angle to 0<theta<2PI
		while (this.angle > Math.PI*2) {
			this.angle -= Math.PI*2;
		}
		// --
	}

	particle_type.prototype.clear = function() {
		this.x			= 0;
		this.y			= 0;
		this.vx			= 0;
		this.vy			= 0;
		this.size		= 0;
		this.angle		= 0;
		this.spin		= 0;
		this.seperation	= 0;
	}

	particle_type.prototype.draw = function(shade){

		function draw_ball(x, y, size, r, g, b){
			var colourstring = "rgb(".concat(r, ",", g, ",", b, ")");
			context.beginPath();
			context.arc(x,y,size, 0, 2 * Math.PI, false);
			context.fillStyle = colourstring;
			context.fill();
		}

		draw_ball(
			this.x,
			canvas.height - this.y,
			this.size,
			Math.round(this.speed() * 30) + shade, shade, shade
		);
		draw_ball(
			this.x + Math.cos(this.angle) * this.size / 2,
			canvas.height - (this.y + Math.sin(this.angle) * this.size / 2),
			this.size / 5,
			255, 255, 255
		);
	}

	particle_type.prototype.collide = function(that, e, f){
		// Particle1 = this, Particle2 = that
		if (interaction.seperation <= interaction.size){
			// theta = angle from x-axis to line P1P2 (anticlockwise)
			var cos_theta 	= interaction.x / interaction.seperation;
			var sin_theta 	= interaction.y / interaction.seperation;
			var u_spin1 	= this.spin;
			var u_spin2 	= that.spin;
			var mu1 		= 1 + this.mass() / that.mass();
			var mu2 		= 1 + that.mass() / this.mass();
			var r1 			= this.size;
			var r2 			= that.size;
			var alpha 		= 2 / 5;

			// calculate P1 vector for first transform
			var u1x = this.vx;
			var u1y = this.vy;

			//transform 1 (coords about stationary P1 ie apply -u1x,-u1y)
			var u2x = that.vx - u1x;
			var u2y = that.vy - u1y;

			// transform 2 (rotate coords to make P1P2 intersect along x-axis ie. theta=0)
			u2x = (cos_theta * u2x) + (sin_theta * u2y); 			// approach velocity
			u2y = (cos_theta * u2y) - (sin_theta * interaction.vx); // velocity perpendicular to approach

			if (u2x < 0){
				var max_stopping_friction_coeff = Math.abs((u2y - r2 * u_spin2 - r1 * u_spin1) * alpha / (u2x * (e + 1) * (alpha + 1)));
				if (u2y > (r1 * u_spin1 + r2 * u_spin2)){
					f = -Math.min(f, max_stopping_friction_coeff);
				}
				if (u2y == (r1 * u_spin1 + r2 * u_spin2)){
					f=0;
				}
				if (u2y < (r1 * u_spin1 + r2 * u_spin2)){
					f = Math.min(f, max_stopping_friction_coeff);
				}

				var v1x = u2x * (e + 1) / mu1;
				var v2x = u2x * ((1 / mu1) - (e / mu2));
				var v1y = u2x * f * (e + 1) / mu1;
				var v2y = u2y - u2x * f * (e + 1) / mu2;
				var v_spin1 = u_spin1 + u2x * f * (e + 1) / (alpha * r1 * mu1);
				var v_spin2 = u_spin2 + u2x * f * (e + 1) / (alpha * r2 * mu2);

				// reverse transform 2 then reverse transform 1 for P1 then P2
				this.vx 	= (v1x * cos_theta - v1y * sin_theta) + u1x;
				this.vy 	= (v1y * cos_theta + v1x * sin_theta) + u1y;
				this.spin 	= v_spin1;
				that.vx 	= (v2x * cos_theta - v2y * sin_theta) + u1x;
				that.vy 	= (v2y * cos_theta + v2x * sin_theta) + u1y;
				that.spin 	= v_spin2;
			}

			if (interaction.seperation < interaction.size){
				// !!! NOTE : This compressability parameter is HARD CODED !!
				var anti_squeeze = 0.5 * (interaction.size - interaction.seperation);
				var delta2 = anti_squeeze / (1 + that.mass() / this.mass());
				var delta1 = anti_squeeze - delta2;
				this.x += -delta1 * cos_theta;
				this.y += -delta1 * sin_theta;
				that.x +=  delta2 * cos_theta;
				that.y +=  delta2 * sin_theta;
			}
		}
	}

	particle_type.prototype.attract = function(that) {

		var force = distance_force * interaction.mass / (interaction.seperation * interaction.seperation);

		this.vx +=  force * interaction.vector.x / this.mass();
		this.vy +=  force * interaction.vector.y / this.mass();
		that.vx += -force * interaction.vector.x / that.mass();
		that.vy += -force * interaction.vector.y / that.mass();
		this.spin += 0;
		that.spin += 0;
	}

	particle_type.prototype.stick = function(that) {

		var force = interaction.mass * (interaction.seperation - interaction.size) / (this.mass() + that.mass());

		this.vx +=  force * interaction.vector.x / this.mass();
		this.vy +=  force * interaction.vector.y / this.mass();
		that.vx += -force * interaction.vector.x / that.mass();
		that.vy += -force * interaction.vector.y / that.mass();
		this.spin += 0;
		that.spin += 0;
	}

	particle_type.prototype.stabilise = function() {
		while (this.speed() > speedCap){
			this.vx *= 0.9;
			this.vy *= 0.9;
		}
	}

	particle_type.prototype.boundary_test = function() {
		if (boundary_flag_x == -1){
			if (this.x < this.size){
				wall.clear();
				wall.size 	= 200;
				wall.y 		= this.y
				wall.x 		= -wall.size;
				interaction.resolve(wall, this);
				wall.collide(this, restitution_b, friction_b);
			}
			if (this.x > (canvas.width - this.size)){
				wall.clear();
				wall.size 	= 200;
				wall.y 		= this.y
				wall.x 		= canvas.width + wall.size;
				interaction.resolve(wall, this);
				wall.collide(this, restitution_b, friction_b);
			}
		} else if (boundary_flag_x == 1){
			while (this.x < this.size){
				this.x += canvas.width;
			}
			while (this.x > canvas.width){
				this.x -= canvas.width;
			}
		}

		if (boundary_flag_y == -1){
			if (this.y < this.size){
				wall.clear();
				wall.size = 200;
				wall.x = this.x
				wall.y = -wall.size;
				interaction.resolve(wall, this);
				wall.collide(this, restitution_b, friction_b);
			}
			if (this.y > (canvas.height - this.size)){
				wall.clear();
				wall.size 	= 200;
				wall.x 		= this.x
				wall.y 		= canvas.height + wall.size;
				interaction.resolve(wall, this);
				wall.collide(this, restitution_b, friction_b);
			}
		} else if (boundary_flag_y == 1){
			while (this.y < this.size){
				this.y += canvas.height;
			}
			while (this.y > canvas.height){
				this.y -= canvas.height;
			}
		}
	}

	function interaction_type(){
		particle_type.call(this);
	}

	interaction_type.prototype.clear = function(){
		particle_type.prototype.clear.call(this);
	}

	interaction_type.prototype.resolve = function(P1, P2){
		this.size 	= P1.size + P2.size; 		// Interaction distance at point of contact
		this.x 		= P2.x - P1.x; 				// Contact vector
		this.y 		= P2.y - P1.y;

		this.vx 	= P2.vx - P1.vx; 			// (Approach)/Seperation vector
		this.vy 	= P2.vy - P1.vy;
		this.mass 	= P1.mass() * P2.mass();	// Interaction mass

 		//!!NOTE!! : Stability truncation applied before calculating force vector : HARD CODED!!
		this.seperation = Math.max(modulus(this.x, this.y), this.size / 4);
		// --

		this.vector = {
			x : this.x / this.seperation,
			y : this.y / this.seperation
		}
	}

	// Rubber hammock
	function rubberExample(){

		// Should push Magnets and Attachments NOT particles

		for (i = 0; i < canvas.width * 0.75; i += 2 * 2){
			magnet.push(new particle_type(i, canvas.height * (1 - i / canvas.width), 0, 0, 2));
		}

		attachment.push(new particle_type(0, canvas.height, 0, 0, 5));
		attachment.push(new particle_type(canvas.width * 0.75, canvas.height * 0.25, 0, 0, 5));
		attachment[0].magnet_number = 0;
		attachment[1].magnet_number = magnet.length - 1;

		particle.push(new particle_type(canvas.width * 0.5, 40, 0.4, -0.5, 20));
		particle.push(new particle_type(canvas.width - 50, 10, 0.5, 0, 10));
		particle[particle.length - 2].spin = -0.1;
		particle[particle.length - 1].spin = -0.5;
	}

</script></head><body></body></html>
