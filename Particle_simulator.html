<html><head><canvas id="myCanvas" width=500 height=200 style="border:1px dotted"></canvas></br>
<script >

	var canvas = document.getElementById('myCanvas'); var context = canvas.getContext('2d'),

		particles	= [],
		magnets		= [],
		attachments	= [],

		gravity			= -0.001,
		friction_p		= 1,
		friction_b		= 10,
		restitution_p	= 1,
		restitution_b	= 1,
		boundary_flag	= -1,
		distance_force	= 0,
		speedCap		= 50,

		timerAnimate = setInterval(animate, 30),
		timerIterate = setInterval(iterate, 1);

	function iterate(){

		// -- 1. Iterate through the Particles. Resolving the Particle-to-Particle interactions
		for (var i = 0; i < particles.length; i++){

			for (var j = i + 1; j < particles.length; j++){
				interaction.resolve(particles[i], particles[j]);
				particles[i].collide(particles[j], restitution_p, friction_p);
				particles[i].attract(particles[j]);
			}

			particles[i].boundary();
			particles[i].stabilise();
			particles[i].update();
		}
		// --

		// -- 2. Iterate throught the Magnets.
		// -- Resolving the Magnet-to-Particle, Magnet-to-Magnet & Magnet-to-Attachement interactions
		for (var i = 0; i < magnets.length; i++){

			// -- Magnets Phyiscal collision barrier to particles
			for (var j = 0; j < particles.length; j++){
				interaction.resolve(magnets[i], particles[j]);
				magnets[i].collide(particles[j], restitution_p, friction_p);
			}
			// --

			// -- Magnets attracted in order
			if (i != magnets.length - 1){
				interaction.resolve(magnets[i], magnets[i + 1]);
				magnets[i].stick(magnets[i + 1]);
			}
			// --

			// -- Attachments are ghost objects that attract a specific magnet #
			for (var j = 0; j < attachments.length; j++){
				if (i == attachments[j].magnet_number){
					interaction.resolve(magnets[i], attachments[j]);
					magnets[i].stick(attachments[j]);
				}
			}
			// --

			magnets[i].boundary();
			magnets[i].stabilise();
			magnets[i].update( -0.01 * magnets[i].mass() ); // Dampen the magnets with drag
		}
	}

	function animate(){
		function draw_all_of(type, shade){
			for (var i = 0; i < type.length; i++){
				type[i].draw(shade);
			}
		}

		canvas.width = canvas.width;
		draw_all_of(particles, 0);
		draw_all_of(magnets, 100);
		draw_all_of(attachments, 200);
	}

	// -- Basic Primitive Object has Mass and Collide methods ***TO BE CHANGED WITH TRIANGLES***
	function Primitive(x, y, vx, vy, size, angle, spin){
		this.x		= x || 0;
		this.y		= y || 0;
		this.vx		= vx || 0;
		this.vy		= vy || 0;
		this.size	= size  || 0;
		this.angle	= angle || 0;
		this.spin	= spin  || 0;
	}

	Primitive.prototype.mass = function (){
		var mass = (4/3) * Math.PI * this.size * this.size * this.size;
		return mass;
	}

	Primitive.prototype.collide = function(that, e, f){
		// Particle1 = this, Particle2 = that
		if (interaction.seperation <= interaction.size){
			// theta = angle from x-axis to line P1P2 (anticlockwise)
			var cos_theta 	= interaction.x / interaction.seperation;
			var sin_theta 	= interaction.y / interaction.seperation;
			var u_spin1 	= this.spin;
			var u_spin2 	= that.spin;
			var mu1 		= 1 + this.mass() / that.mass();
			var mu2 		= 1 + that.mass() / this.mass();
			var r1 			= this.size;
			var r2 			= that.size;
			var alpha 		= 2 / 5;

			// calculate P1 vector for first transform
			var u1x = this.vx;
			var u1y = this.vy;

			//transform 1 (coords about stationary P1 ie apply -u1x,-u1y)
			var u2x = that.vx - u1x;
			var u2y = that.vy - u1y;

			// transform 2 (rotate coords to make P1P2 intersect along x-axis ie. theta=0)
			u2x = (cos_theta * u2x) + (sin_theta * u2y); 			// approach velocity
			u2y = (cos_theta * u2y) - (sin_theta * interaction.vx); // velocity perpendicular to approach

			if (u2x < 0){
				var max_stopping_friction_coeff = Math.abs((u2y - r2 * u_spin2 - r1 * u_spin1) * alpha / (u2x * (e + 1) * (alpha + 1)));
				if (u2y > (r1 * u_spin1 + r2 * u_spin2)){
					f = -Math.min(f, max_stopping_friction_coeff);
				}
				if (u2y == (r1 * u_spin1 + r2 * u_spin2)){
					f=0;
				}
				if (u2y < (r1 * u_spin1 + r2 * u_spin2)){
					f = Math.min(f, max_stopping_friction_coeff);
				}

				var v1x = u2x * (e + 1) / mu1;
				var v2x = u2x * ((1 / mu1) - (e / mu2));
				var v1y = u2x * f * (e + 1) / mu1;
				var v2y = u2y - u2x * f * (e + 1) / mu2;
				var v_spin1 = u_spin1 + u2x * f * (e + 1) / (alpha * r1 * mu1);
				var v_spin2 = u_spin2 + u2x * f * (e + 1) / (alpha * r2 * mu2);

				// reverse transform 2 then reverse transform 1 for P1 then P2
				this.vx 	= (v1x * cos_theta - v1y * sin_theta) + u1x;
				this.vy 	= (v1y * cos_theta + v1x * sin_theta) + u1y;
				this.spin 	= v_spin1;
				that.vx 	= (v2x * cos_theta - v2y * sin_theta) + u1x;
				that.vy 	= (v2y * cos_theta + v2x * sin_theta) + u1y;
				that.spin 	= v_spin2;
			}

			if (interaction.seperation < interaction.size){
				// !!! NOTE : This compressability parameter is HARD CODED !!
				var anti_squeeze = 0.5 * (interaction.size - interaction.seperation);
				var delta2 = anti_squeeze / (1 + that.mass() / this.mass());
				var delta1 = anti_squeeze - delta2;
				this.x += -delta1 * cos_theta;
				this.y += -delta1 * sin_theta;
				that.x +=  delta2 * cos_theta;
				that.y +=  delta2 * sin_theta;
			}
		}
	}
	// --

	// -- Particle is a BALL ONLY and a subset of Primitive. It can attract from a distance.
	function Particle(x, y, vx, vy, size, angle, spin){
		this.base = Primitive;
		this.base(x, y, vx, vy, size, angle, spin);
	}
	Particle.prototype = new Primitive;

	Particle.prototype.attract = function(that) {

		// F = Gm1m2/r^2
		var force = distance_force * interaction.mass / (interaction.seperation * interaction.seperation);

		this.vx +=  force * interaction.vector.x / this.mass();
		this.vy +=  force * interaction.vector.y / this.mass();
		that.vx += -force * interaction.vector.x / that.mass();
		that.vy += -force * interaction.vector.y / that.mass();
		this.spin += 0;
		that.spin += 0;
	}

	Particle.prototype.speed = function (){
		var speed = modulus(this.vx, this.vy);
		return speed;
	}

	Particle.prototype.draw = function(shade){

		function draw_ball(x, y, size, r, g, b){
			var colourstring = "rgb(".concat(r, ",", g, ",", b, ")");
			context.beginPath();
			context.arc(x,y,size, 0, 2 * Math.PI, false);
			context.fillStyle = colourstring;
			context.fill();
		}

		draw_ball(
			this.x,
			canvas.height - this.y,
			this.size,
			Math.round(this.speed() * 30) + shade, shade, shade
		);
		draw_ball(
			this.x + Math.cos(this.angle) * this.size / 2,
			canvas.height - (this.y + Math.sin(this.angle) * this.size / 2),
			this.size / 5,
			255, 255, 255
		);
	}

	Particle.prototype.update = function(drag){

		// -- Modify speed due to gravity (& other field forces)
		this.vy 	+= gravity;
		// --

		// -- Modify speed due to drag
		if (drag){
			if (this.vx > 0){
				this.vx += Math.max(drag*this.vx*this.speed() / this.mass(), -this.vx);
			}
			else {
				this.vx += Math.min(drag*this.vx*this.speed() / this.mass(), -this.vx);
			}
			if (this.vy > 0){
				this.vy += Math.max(drag*this.vy*this.speed() / this.mass(), -this.vy);
			}
			else {
				this.vy += Math.min(drag*this.vy*this.speed() / this.mass(), -this.vy);
			}
		}
		// --

		// -- Update position based on speed
		this.x 		+= this.vx;
		this.y 		+= this.vy;
		this.angle 	+= this.spin;
		// --

		// -- Normalise angle to 0<theta<2PI
		while (this.angle > Math.PI*2) {
			this.angle -= Math.PI*2;
		}
		// --
	}

	Particle.prototype.stabilise = function() {
		while (this.speed() > speedCap){
			this.vx *= 0.9;
			this.vy *= 0.9;
		}
	}

	Particle.prototype.boundary = function() {
		if (boundary_flag == -1){
			if (this.x < this.size){
				wall.clear();
				wall.y 		= this.y
				wall.x 		= -wall.size;
				interaction.resolve(wall, this);
				wall.collide(this, restitution_b, friction_b);
			}
			if (this.x > (canvas.width - this.size)){
				wall.clear();
				wall.y 		= this.y
				wall.x 		= canvas.width + wall.size;
				interaction.resolve(wall, this);
				wall.collide(this, restitution_b, friction_b);
			}
			if (this.y < this.size){
				wall.clear();
				wall.x = this.x
				wall.y = -wall.size;
				interaction.resolve(wall, this);
				wall.collide(this, restitution_b, friction_b);
			}
			if (this.y > (canvas.height - this.size)){
				wall.clear();
				wall.x 		= this.x
				wall.y 		= canvas.height + wall.size;
				interaction.resolve(wall, this);
				wall.collide(this, restitution_b, friction_b);
			}

		} else if (boundary_flag == 1){
			while (this.x < this.size){
				this.x += canvas.width;
			}
			while (this.x > canvas.width){
				this.x -= canvas.width;
			}
			while (this.y < this.size){
				this.y += canvas.height;
			}
			while (this.y > canvas.height){
				this.y -= canvas.height;
			}
		}
	}
	// --

	// -- Magnet is a subset of Particle. And can stick() [stronger / different attraction]
	function Magnet(x, y, size){
		this.base = Particle;
		this.base(x, y, 0, 0, size);
	}
	Magnet.prototype = new Particle;
	Magnet.prototype.stick = function(that) {

		// F = m1m2*r/(m1+m2)
		var force = interaction.mass * (interaction.seperation - interaction.size) / (this.mass() + that.mass());

		this.vx +=  force * interaction.vector.x / this.mass();
		this.vy +=  force * interaction.vector.y / this.mass();
		that.vx += -force * interaction.vector.x / that.mass();
		that.vy += -force * interaction.vector.y / that.mass();
		this.spin += 0;
		that.spin += 0;
	}
	// --

	// -- Attachment is a fixed Ghost of a magnet. Targets only ONE magnet.
	function Attachement(x, y, magnet_number){
		this.size = 10;
		this.base = Magnet;
		this.base(x, y, this.size);
		this.magnet_number = magnet_number;
	}
	Attachement.prototype = new Magnet;
	// --

	// -- Interaction is used to resolve to objects, and refered to by collide, stick, attract
	function Interaction(){
		Primitive.call(this);
	}
	Interaction.prototype = new Primitive;
	Interaction.prototype.resolve = function(P1, P2){
		this.size 	= P1.size + P2.size; 		// Interaction distance at point of contact
		this.x 		= P2.x - P1.x; 				// Contact vector
		this.y 		= P2.y - P1.y;

		this.vx 	= P2.vx - P1.vx; 			// (Approach)/Seperation vector
		this.vy 	= P2.vy - P1.vy;
		this.mass 	= P1.mass() * P2.mass();	// Interaction mass

		this.seperation = Math.max(modulus(this.x, this.y), this.size / 100);

		this.vector = {
			x : this.x / this.seperation,
			y : this.y / this.seperation
		}
	}
	var interaction = new Interaction; // interaction object is useful to have seperation x,y,vx,vy,mass etc
	// --

	// -- Wall is a size = 200 Primitive, that only collides.
	function Wall(){
		Primitive.call(this);
		this.size = 200;
	}
	Wall.prototype = new Primitive;
	Wall.prototype.clear = function() {
		this.x			= 0;
		this.y			= 0;
		this.vx			= 0;
		this.vy			= 0;
		this.angle		= 0;
		this.spin		= 0;
	}
	var	wall = new Wall;			// simulate wall as a infinitely large particle
	// --

	// Rubber hammock
	function rubberExample(){

		var w = canvas.width,
			h = canvas.height;

		for (i = 0; i < w * 0.75; i += 2 * 2){
			magnets.push(new Magnet(i, h * (1 - i / w), 2));
		}

		attachments.push(new Attachement(0, 		h, 			magnet_number=0)	);
		attachments.push(new Attachement(w * 0.75, 	h * 0.25, 	magnets.length - 1)	);
		attachments.push(new Attachement(w * 0.5, 	h * 0.5, 	60)					);

		particles.push(new Particle(w * 0.5, 40, 0.4, -0.5, 20, 0, spin=-0.1));
		particles.push(new Particle(w - 50, 10, 0.5, 0, 10, 0, spin=-0.5));
	}

	function modulus(x, y) {
		return Math.sqrt(x * x + y * y);
	}


</script></head><body></body></html>
